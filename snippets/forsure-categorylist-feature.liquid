{% style %}

.feature-title-container {
    display: flex;
    align-items: center;
    /* justify-content: space-between; */
    gap: 8px;
}


/* Feature UI Styles */
.feature-toggle-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 2px 6px;
    /* margin-right: 8px; */
    border-radius: 3px;
    transition: all 0.2s ease;
    font-size: 12px;
    color: #2255ff;
    min-width: 5rem;
}

.feature-toggle-btn:hover {
    background-color: #e3f2fd;
    transform: scale(1.1);
}

.feature-toggle-btn.expanded {
    background-color: #2255ff;
    color: white;
}

.feature-toggle-btn i {
    transition: transform 0.3s ease;
}

.feature-toggle-btn.expanded i {
    transform: rotate(90deg);
}

.feature-toggle-btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    color: #999;
}

.feature-toggle-btn.disabled:hover {
    background-color: transparent;
    transform: none;
}

.feature-row {
    background-color: #f8f9fa !important;
    border-left: 4px solid #2255ff !important;
}

.feature-row td {
    padding: 8px 12px !important;
    font-size: 13px;
    color: #666;
}

.feature-row td:first-child {
    padding-left: 40px !important;
    position: relative;
}

.od-branch {
  width: 14px; height: 14px; border-left: 2px solid #2255ff; border-bottom: 2px solid #2255ff; display: flex!important;transform: translateY(-35%);margin: auto;
  border-radius: 0 0 0 4px;
}

/* Ensure feature rows are visible */
#editableTable tbody tr.feature-row {
    display: table-row !important;
}

/* Hide feature rows when collapsed */
#editableTable tbody tr.feature-row.hidden {
    display: none !important;
}

.feature-badge {
    display: inline-block;
    background-color: #2255ff;
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    margin-left: 8px;
    vertical-align: middle;
}

.feature-input {
    width: 100%;
    padding: 4px 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-size: 12px;
}

.feature-input:focus {
    border-color: #2255ff;
    outline: none;
    box-shadow: 0 0 0 2px rgba(34, 85, 255, 0.2);
}

.feature-actions {
    display: flex;
    gap: 4px;
    align-items: center;
    margin-left: auto;
}

.feature-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 2px;
    font-size: 10px;
    transition: all 0.2s ease;
}

.feature-action-btn.save {
    color: #28a745;
}

.feature-action-btn.save:hover {
    background-color: #d4edda;
}

.feature-action-btn.delete {
    color: #dc3545;
}

.feature-action-btn.delete:hover {
    background-color: #f8d7da;
}

.feature-action-btn.cancel {
    color: #6c757d;
}

.feature-action-btn.cancel:hover {
    background-color: #e2e3e5;
}

.feature-add-btn {
    background-color: #17161c;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 11px;
    margin-left: 8px;
    transition: all 0.2s ease;
    display: inline-block;
    position: relative;
    margin-left: auto;
}

.feature-add-btn:hover {
    background-color: #17161c;
    transform: scale(1.05);
}

.feature-add-btn i {
    margin-right: 4px;
}

/* keep child isolated from DataTables styling */
/* remove the default child cell padding so the subtable aligns edge-to-edge */
table.dataTable tr.child td { padding: 0 !important; border: 0 !important; }

/* make the subtable look like the main table */
.feature-row-table {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;            /* required for colgroup widths */
}
.feature-row-table td {
  padding: 8px 10px;              /* match your main table td padding */
  border-top: 1px solid #ddd;     /* match row separators */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* optional: subtle background for child rows */
.feature-child .feature-row-table td { background: #fafafa; }

.feature-child {
    padding: 0!important;
}

#editableTable, #editableTable th, #editableTable td,
.feature-row-table, .feature-row-table td { box-sizing: border-box; }

/* child: no left/right borders that would steal width */
table.dataTable tr.child td { padding:0 !important; border:0 !important; }

/* child uses parent’s vertical gridlines; avoid double lines */
.feature-row-table td { border-top:1px solid #ddd; border-left:0; border-right:0; box-sizing:border-box; }
#editableTable,
#editableTable th,
#editableTable td,
.feature-row-table,
.feature-row-table td {
  box-sizing: border-box;
}

.feature-row-table,  .feature-row-table td:first-child, .feature-row-table td:last-child {
    border-left: none !important;
    border-right: none !important;
}

{% endstyle %}

  <!-- Feature Modal -->
<div id="featureModal" class="modal losensitive" style="display: none;">
    <div class="modal-content" style="width: 45vw;">
        <span id="closeFeatureModal" class="close" onclick="closeFeatureModal()">&times;</span>
        <h2 style="margin: 2rem;" id="featureModalTitle">Add Feature</h2>
        <div style="margin: 2rem;">
            <label for="featureName" style="width: 50%;" title="The feature name is used to identify the feature in the report.">Feature Name:</label>
            <input type="text" id="featureName" placeholder="e.g., Sub-SKU, Package Type" required>
        </div>
        <div style="margin: 2rem;">
            <label for="featureProvider" style="width: 50%;" title="Choosing a data provider will automatically fetch the data from the provider.">Data Provider (Optional):</label>
            <select id="featureProvider" class="selectpicker">
                <option value="">Manual Entry</option>
                <option value="external_api">External API</option>
                <option value="shopify">Shopify</option>
                <option value="erp">ERP System</option>
            </select>
        </div>
        <div style="display: flex; justify-content: space-between;margin: 2rem;">
            <div>
                <button class="button" style="background-color: #17161c;" onclick="closeFeatureModal()">Cancel</button>
            </div>
            <div>
                <button class="button" onclick="saveFeature(event)" id="featureSubmitBtn">Save Feature</button>
            </div>
        </div>
    </div>
</div>
<script>
    // Feature Management System
let currentFeatureSku = null;
let currentFeatureId = null;
let featureRows = new Map(); // Map to store feature rows for each SKU


function addFeature(row, sku) {
    const firstCell = row.querySelector('td:first-child');
    if (!firstCell) {
        console.error('No first cell found for SKU:', sku);
        return;
    }
    
    // Check if button already exists
    if (firstCell.querySelector('.feature-add-btn')) {
        console.log('Feature add button already exists for SKU:', sku);
        return;
    }
    var text = firstCell.textContent;
    firstCell.innerHTML = '';
    var div = document.createElement('div');
    div.className = 'feature-title-container';
    var textContainer = document.createElement('div');
    textContainer.className = 'feature-title-text';
    textContainer.textContent = text;
    textContainer.onclick = () => {
        editName(textContainer);
    };
    firstCell.appendChild(div);
    div.appendChild(textContainer);
    addFeatureButtonToRow(div, sku, row);
    addFeatureToggleButton(div, sku, row);

}

// Add feature button to row
function addFeatureButtonToRow(firstCell, sku, rowNode) {
    if (!firstCell) return;
    if (firstCell.querySelector('.feature-add-btn')) return;
    const addBtn = document.createElement('button');
    addBtn.className = 'feature-add-btn';
    addBtn.innerHTML = '<i class="fas fa-plus"></i> Add Sub-SKU';
    addBtn.onclick = () => {
        openFeatureModal(sku);
    };
    
    firstCell.appendChild(addBtn);
}


// Add feature toggle button to a row
function addFeatureToggleButton(firstCell, sku, rowNode) {
    if (!firstCell) return;
    // Check if button already exists
    if (firstCell.querySelector('.feature-toggle-btn')) return;
    
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'feature-toggle-btn';
    toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
    toggleBtn.title = 'Click to load features';
    toggleBtn.onclick = () => {
        console.log('Toggle button clicked for SKU:', sku);
        toggleFeatures(sku, rowNode);
    };
    
    // Initially disable the button until we know if features exist
    toggleBtn.classList.add('disabled');
    toggleBtn.title = 'Loading features...';
    
    firstCell.insertBefore(toggleBtn, firstCell.firstChild);
    
    // Check if features exist for this SKU
    checkFeaturesExist(sku, toggleBtn);
}

// Check if features exist for a SKU
async function checkFeaturesExist(sku, toggleBtn) {
    try {
        const response = await unifiedSendRequest(`${CATEGORYLISTFEATURES}/${sku}?version=${versionId}`, {method: 'GET'});
        const features = response || [];
        
        // Enable toggle button if features exist
        if (features.length > 0) {
            toggleBtn.classList.remove('disabled');
            toggleBtn.title = 'Toggle Features';
            
            // Add feature count badge
            const badge = document.createElement('span');
            badge.className = 'feature-badge';
            badge.textContent = features.length;
            toggleBtn.appendChild(badge);
        } else {
            toggleBtn.classList.add('disabled');
            toggleBtn.title = 'No features available';
        }
        
    } catch (error) {
        console.error('Error checking features:', error);
        // Disable button on error
        toggleBtn.classList.add('disabled');
        toggleBtn.title = 'Error loading features';
        console.log('Toggle button disabled due to error for SKU:', sku);
    }
}

let visibleCols = [];      // [{idx, key, widthPx, cls}]
const featureCache = new Map();
const expandedSKUs = new Set();


function syncLayout(dt){
    const table = dt.table().node();
    const avail = table.clientWidth;               // excludes scrollbar
    visibleCols = [];
    dt.columns(':visible').every(function(){
      const th = this.header();
      const cs = getComputedStyle(th);
      const w  = th.getBoundingClientRect().width; // used width
      const pct = (w / avail) * 100;
      visibleCols.push({
        key: this.dataSrc(),
        widthPct: pct.toFixed(5) + '%',
        padL: cs.paddingLeft,
        padR: cs.paddingRight,
        align: cs.textAlign,
        cls: th.className || ''
      });
    });
    console.log('Visible columns:', visibleCols);
    applyColgroupToMain(dt);
    applyColgroupsToChildren(dt);
}

function buildColgroupEl() {
    const cg = document.createElement('colgroup');
    cg.setAttribute('data-role', 'main-colgroup');
    for (const c of visibleCols) {
      const col = document.createElement('col');
      col.style.width = c.widthPct;       // or c.widthPx
      cg.appendChild(col);
    }
    return cg;
}
  
function applyColgroupToMain(dt) {
    if (!visibleCols.length) return;
    const table = dt.table().node();
    const newCg = buildColgroupEl();
  
    // replace only the direct child colgroup
    const existing =
      table.querySelector(':scope > colgroup[data-role="main-colgroup"]') ||
      table.querySelector(':scope > colgroup');
  
    if (existing) {
      table.replaceChild(newCg, existing);
    } else {
      const ref = table.querySelector(':scope > thead, :scope > tbody, :scope > tfoot');
      table.insertBefore(newCg, ref);
    }
}
  
function applyColgroupsToChildren(dt) {
if (!visibleCols.length) return;
const newCg = buildColgroupEl();

// update every open child table without touching the main table
const root = dt.table().node().parentElement; // wrapper containing child rows
root.querySelectorAll('tr.feature-child table.feature-row-table').forEach(tbl => {
    const old =
    tbl.querySelector(':scope > colgroup[data-role="main-colgroup"]') ||
    tbl.querySelector(':scope > colgroup');

    const cgClone = newCg.cloneNode(true); // reuse widths for each table

    if (old) {
    tbl.replaceChild(cgClone, old);
    } else {
    const ref = tbl.querySelector(':scope > thead, :scope > tbody, :scope > tfoot');
    tbl.insertBefore(cgClone, ref);
    }
});
}
  
  
{% comment %} new ResizeObserver(() => { const dt = $('#editableTable').DataTable(); syncLayout(dt); dt.rows({page:'current'}).every(function(){ const sku=this.data()[idcol]||this.data().SKU; if(expandedSKUs.has(sku)) this.child(buildChildHTML(featureCache.get(sku).features),'feature-child').show(); }); }).observe($('#editableTable').get(0)); {% endcomment %}

{% comment %} // capture widths after init and whenever layout changes
function captureColWidths(dt) {
    headers = dt.columns().dataSrc().toArray();
    colWidthsPx = [];
    dt.columns().every(function () {
      const w = $(this.header()).outerWidth();
      colWidthsPx.push(`${Math.max(20, Math.floor(w))}px`);
    });
} {% endcomment %}

// build the child table to look like a seamless continuation
function buildChildHTML(features) {
    const wrapper = document.createElement('div');
    wrapper.className = 'feature-wrap';
  
    const table = document.createElement('table');
    table.className = 'feature-row-table';
    wrapper.appendChild(table);
  
    // build colgroup
    const colgroup = document.createElement('colgroup');
    visibleCols.forEach(c => {
      const col = document.createElement('col');
      col.style.width = c.widthPct; // or c.widthPx
      colgroup.appendChild(col);
    });
    table.appendChild(colgroup);
  
    const tbody = document.createElement('tbody');
    table.appendChild(tbody);
  
    (features || []).forEach(f => {
        const tr = createChildHTML(f, document.createElement('tr'));
        tbody.appendChild(tr);
    });
  
    return wrapper; // a DOM element, not a string
}

function createChildHTML(feature, tr) {
  
    visibleCols.forEach((c, i) => {
        const tdInner = document.createElement('td');
        tdInner.className = c.cls;
        tdInner.style.textAlign = c.align;
        tdInner.style.paddingLeft = c.padL;
        tdInner.style.paddingRight = c.padR;
  
        if (i === 0) {
          // insert the feature cell content element (with handlers intact)
          tdInner.appendChild(createFeatureCellContent(feature));
        } else {
          const val = feature?.data_local?.[c.key] ?? feature?.data?.[c.key] ?? '';
          const txt = escapeHtml(String(val));
          tdInner.textContent = txt;
          tdInner.title = txt; // tooltip for truncated text
          getValidEntry(val, c.key, tdInner);
          tdInner.onclick = () => {
            const categoryTable = $('#editableTable').DataTable();
            inlineEditFeature(categoryTable, tdInner, tdInner.textContent, c.key, feature);
          };
        }
        tr.appendChild(tdInner);
    });
    return tr;
}
  
  // your toggle reuses buildChildHTML(features, dt)
async function toggleFeatures(sku, rowNode) {
    const table = $('#editableTable').DataTable();
    syncLayout(table);

    const row = table.row(rowNode);
    const btn = rowNode.querySelector('.feature-toggle-btn');
    if (row.child.isShown()) { row.child.hide(); btn.classList.remove('expanded'); expandedSKUs.delete(sku); return; }
  
    let features = featureCache.get(`${sku}`)?.features;
    if (!features) {
      const res = await unifiedSendRequest(`${CATEGORYLISTFEATURES}/${sku}?version=${versionId}`, { method: 'GET' });
      features = res || [];
      featureCache.set(`${sku}`, { features });
    }
  
    row.child(buildChildHTML(features, table), 'feature-child').show();
    btn.classList.add('expanded'); expandedSKUs.add(sku);
}

function refreshFeatures() {
    expandedSKUs.forEach(sku => {
        loadAndDisplayFeatures(sku);
    });
}

function refreshFeaturesChangeOrder() {
    const dt  = $('#editableTable').DataTable();
    expandedSKUs.forEach(sku => {
        const rowNode = document.getElementById(`${sku}`);
        const row = dt.row(rowNode);
        row.child.hide();
        const features = featureCache.get(`${sku}`).features;
        const childEl = buildChildHTML(features);
        row.child(childEl, 'feature-child').show();
    });
}


function escapeHtml(s){ return String(s ?? '').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }


async function loadAndDisplayFeatures(sku) {
    console.log('Loading and displaying features for SKU:', sku);
    rowNode = document.getElementById(`${sku}`);
    const dt  = $('#editableTable').DataTable();
    const row = dt.row(rowNode);
    const btn = rowNode.querySelector('.feature-toggle-btn');
  
    try {
      // fetch and cache
        const res = await unifiedSendRequest(`${CATEGORYLISTFEATURES}/${sku}?version=${versionId}`, { method: 'GET' });
        const features = Array.isArray(res) ? res : [];
        featureCache.set(`${sku}`, { features });
  
      // badge update
      if (btn) {
        let badge = btn.querySelector('.feature-badge');
        if (!badge) {
          badge = document.createElement('span');
          badge.className = 'feature-badge';
          btn.appendChild(badge);
        }
        badge.textContent = String(features.length);
        btn.classList.toggle('disabled', false);
        btn.title = features.length ? 'Toggle Features' : 'No features available';
      }
        // ensure column layout is synced
        syncLayout(dt);
      // close if open, then rebuild child
      if (row.child.isShown()) {
        row.child.hide();
        expandedSKUs.delete(sku);
        if (btn) btn.classList.remove('expanded');
      }

      if (features.length === 0) {
        btn.classList.add('disabled');
        btn.title = 'No features available';
        let badge = btn.querySelector('.feature-badge');
        if (badge) {
            badge.remove();
        }

        return;
      }
  
      // build and show child (always render; shows "No features" row if empty)
      const childEl = buildChildHTML(features);
      row.child(childEl, 'feature-child').show();
      expandedSKUs.add(sku);
      if (btn) btn.classList.add('expanded');
  
    } catch (error) {
      console.error('Error loading features:', error);
  
      // disable toggle on hard errors
      if (btn) {
        btn.classList.add('disabled');
        btn.title = 'Error loading features';
      }
      showMessage('Failed to load features', false);
    }
  }

// Create feature cell content with actions
function createFeatureCellContent(feature) {
    const container = document.createElement('div');
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.gap = '8px';
    
    const nameContainer = document.createElement('div');
    var branch = document.createElement('div');
    branch.className = 'od-branch';
    nameContainer.appendChild(branch);
    {% comment %} nameContainer.innerHTML = '└─'; {% endcomment %}
    nameContainer.style.minWidth = '5rem';
    nameContainer.style.justifyContent = 'end';
    nameContainer.style.display = 'flex';
    nameContainer.style.color = '#2255ff';
    nameContainer.style.fontWeight = 'bold';
    container.appendChild(nameContainer);
    const nameSpan = document.createElement('span');
    nameSpan.textContent = feature.name;
    nameSpan.style.fontWeight = 'bold';
    nameSpan.style.color = '#2255ff';
    
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'feature-actions';
    
    // Edit button
    const editBtn = document.createElement('button');
    editBtn.className = 'feature-action-btn save';
    editBtn.innerHTML = `{% render "icon-edit" %}`;
    editBtn.title = 'Edit Feature';
    editBtn.onclick = () => editFeature(feature);
    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'feature-action-btn delete';
    deleteBtn.innerHTML = '<img width="16px" src="{{ section.settings.trashcan | image_url }}" alt="{{ section.settings.trashcan.alt | escape }}" loading="lazy">';
    deleteBtn.title = 'Delete Feature';
    deleteBtn.onclick = () => deleteFeature(feature);
    
    actionsDiv.appendChild(editBtn);
    actionsDiv.appendChild(deleteBtn);
    
    container.appendChild(nameSpan);
    container.appendChild(actionsDiv);
    
    return container;
}

// Open feature modal for adding new feature
function openFeatureModal(sku) {
    currentFeatureSku = sku;
    currentFeatureId = null;
    
    const modal = document.getElementById('featureModal');
    const title = document.getElementById('featureModalTitle');
    const nameInput = document.getElementById('featureName');
    const providerSelect = document.getElementById('featureProvider');
    
    if (!modal) {
        console.error('Feature modal not found!');
        alert('Feature modal not found!');
        return;
    }
    
    title.textContent = 'Add Feature';
    nameInput.value = '';
    providerSelect.value = '';
    
    modal.style.display = 'block';
    
    // Force a repaint
    modal.offsetHeight;
}

// Edit existing feature
function editFeature(feature) {
    console.log('Editing feature:', feature);
    currentFeatureSku = feature.sku;
    currentFeatureId = feature.id;
    
    document.getElementById('featureModalTitle').textContent = 'Edit Feature';
    document.getElementById('featureName').value = feature.name;
    document.getElementById('featureProvider').value = feature.data_provider || '';
    document.getElementById('featureSubmitBtn').textContent = 'Update Feature';
    
    document.getElementById('featureModal').style.display = 'block';
}

// Close feature modal
function closeFeatureModal() {
    document.getElementById('featureModal').style.display = 'none';
    currentFeatureSku = null;
    currentFeatureId = null;
}

// Save feature function
async function saveFeature(event) {
    event.preventDefault();
    const featureName = document.getElementById('featureName').value;
    const featureProvider = document.getElementById('featureProvider').value;
    
    if (!featureName) {
        showMessage('Please fill in all required fields', false);
        return;
    }
    
    try {
        if (currentFeatureId) {
            // Update existing feature
            const formData = new FormData();
            formData.append('data_provider', featureProvider);
            formData.append('feature_name', featureName);
            formData.append('version', versionId);
            
            await unifiedSendRequest(`${CATEGORYLISTFEATURES}/${currentFeatureSku}/${currentFeatureId}`, {
                method: 'PUT',
                formData: formData
            });
            
            showMessage('Feature updated successfully', true);
        } else {
            // Create new feature
            const formData = new FormData();
            formData.append('feature_name', featureName);
            formData.append('data_provider', featureProvider);
            formData.append('version', versionId);
            
            await unifiedSendRequest(`${CATEGORYLISTFEATURES}/${currentFeatureSku}`, {
                method: 'POST',
                formData: formData
            });
            
            showMessage('Feature created successfully', true);
        }
        
        await loadAndDisplayFeatures(currentFeatureSku);
        closeFeatureModal();
        
    } catch (error) {
        console.error('Error saving feature:', error);
        showMessage('Failed to save feature', false);
    }
}


// Delete feature
async function deleteFeature(feature) {
    console.log('Deleting feature:', feature);
    if (!confirm(`Are you sure you want to delete the feature "${feature.name}"?`)) {
        return;
    }
    
    try {
        await unifiedSendRequest(`${CATEGORYLISTFEATURES}/${feature.sku}/${feature.id}?version=${versionId}`, {
            method: 'DELETE'
        });
        
        showMessage('Feature deleted successfully', true);
        {% comment %} newFeatures = featureCache.get(feature.sku).features.filter(f => f.id !== feature.id);
        featureCache.set(feature.sku, { features: newFeatures });

        if (featureCache.get(feature.sku).features.length === 0) {
            featureCache.delete(feature.sku);
        }
        {% endcomment %}
        await loadAndDisplayFeatures(feature.sku);
        
    } catch (error) {
        console.error('Error deleting feature:', error);
        showMessage('Failed to delete feature', false);
    }
}

// Initialize feature system when table is ready
document.addEventListener('DOMContentLoaded', function() {
    // Add click outside to close functionality for feature modal
    const featureModal = document.getElementById('featureModal');
    if (featureModal) {
        featureModal.addEventListener('click', function(event) {
            if (event.target === featureModal) {
                closeFeatureModal();
            }
        });
    }
});
</script>