{% style %}
table {
  border-collapse: collapse;
  width: 100%;
  /* border: none !important; */
  border: 0.1rem solid #17161c !important;
}
th, td {
  border: 0.1rem solid #17161c!important;
  position: relative;
  min-width: fit-content;
}

th.dragging {
  opacity: 0.5;
}

th.drag-over {
  border-left: 3px solid #2255ff;
}

th[draggable="true"] {
  cursor: move;
  user-select: none;
}


#tabs-container {
  display: flex;
  border-bottom: 2px solid #ddd;
  margin-bottom: 1rem;
}

.tab-button {
  height: 40px;
  padding: 10px 15px;
  border: 1px solid #ddd;
  border-bottom: none;
  background-color: #f9f9f9;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.2s ease, color 0.2s ease;
  margin-right: 5px;
  border-radius: 8px 8px 0 0;
}

.tab-button:hover {
  background-color: #eaeaea;
}

.tab-button.active {
  background-color: #2255ff;
  color: #fafafa;
  border-bottom: 2px solid #fff;
  font-weight: bold;
}

#tabs-container .dropdown-toggle {
  width: 10rem;
}
#versionsContainer .dropdown {
  width: fit-content;
}
#versionsContainer {
margin-top: 5px;
}
#tabs-container .dropdown {
  width: fit-content!important;
}


/* Loading spinner */
#loadingSpinner, #loadingSpinnerCalendar {
  border: 4px solid rgba(34, 85, 255, 0.1);
  border-top: 4px solid #2255ff;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: auto;
  display: flex;
}
#loadingSpinnerContainer, #loadingSpinnerCalendarContainer {
  position: absolute;
  top: 60%;
  left: 50%;
  transform: translate(-50%, -50%);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.invalid-entry {
border: 0.4rem solid red!important;
}

#editableTableWrapper {
  width: 100%;
  overflow-x: auto;     /* enable horizontal scroll */
  overflow-y: hidden;
}

#editableTableHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    margin-top: 1rem;
}
#editableTableHeaderLeft {
    display: flex;
    align-items: center;
    gap: 1rem;
}
#editableTableHeaderRight {
    display: flex;
    align-items: center;
    gap: 1rem;
}

#tableWrapper {
  min-width: max-content;
  overflow-x: auto;
}

#editableTable {
  width: fit-content;
  min-width: max-content;
  border-collapse: collapse;
}

#tableBodyWrapper {
  max-height: 75vh;
  overflow-y: auto;
}

#editableTableBody {
  width: fit-content;
  min-width: max-content;
  border-collapse: collapse;
}

.sort-icon {
  font-size: 2rem;
  margin-left: 2rem;
  color: #ccc;
  cursor: pointer;
  user-select: none;
}
.flex-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.active {
    color: #fafafa;
}

#pagination {
    display: flex;
    align-items: center;
}

.pagination-item:hover {
    background-color: #eaeaea;
}

.pagination-item {
    cursor: pointer;
    padding: 0 1rem;
    border-radius: 5px;
}

.dropdown-option:hover {
    background-color: #eaeaea;
}

{% endstyle %}
<div style="display: flex;justify-content: space-between;">
    <div id="tabs-container"></div>
    <div id="versionsContainer">
        <select
              id="categorylistVersions"
              class="selectpicker"
              data-live-search="true"
              data-dropup-auto="false"
              data-size="5"
              data-dropdown-align-right="true">
        </select>
    </div>
</div>
<div id="errorsDiv" style="color: var(--forsure-main-red); display: none;text-align: center"></div>
<div id="editableTableWrapper">
    <div id="editableTableHeader">
        <div id="editableTableHeaderLeft">
            <select id="rowsPerPage">
                <option value="10">10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
            </select>
            Rows per page
        </div>
        <div id="editableTableHeaderRight">
            Search: <input type="text" id="search" placeholder="Search" oninput="getCategorylistItems()">
        </div>
    </div>
    <div id="tableWrapper">
        <table id="editableTable">
        <thead>
            <tr>
            </tr>
        </thead>
        </table>
        <div id="tableBodyWrapper">
        <table id="editableTableBody">
            <tbody></tbody>
        </table>
        </div>
    </div>
    <div id="tableFooter" style="display: none;justify-content: space-between;margin-top: 1rem;">
        <div id="tableFooterLeft">
            Showing <span id="offset"></span> to <span id="offsetEnd"></span> of <span id="total"></span> entries
        </div>
        <div id="tableFooterRight">
            <div id="pagination">
            </div>
        </div>
    </div>
</div>
<script>
    
var versionId = null;
async function fillVersionDropdown() {
    try {
        document.getElementById('activateEditMode').disabled = true;
        document.getElementById('activateEditMode').style.backgroundColor = '#ddd';
        document.getElementById('activateEditMode').style.cursor = 'not-allowed';
        document.getElementById('activateEditMode').onclick = null;
        let data = await unifiedSendRequest(CATEGORYLISTVERSION, {method: 'GET'});

        if (!data || data.length === 0) {
            {% comment %} data = generateMockVersions(); {% endcomment %}
            document.getElementById('versionsContainer').style.display = 'none';
            document.getElementById('activateEditMode').disabled = true;
            document.getElementById('activateEditMode').style.backgroundColor = '#ddd';
            document.getElementById('activateEditMode').style.cursor = 'not-allowed';
            document.getElementById('activateEditMode').onclick = null;
            return;
        }
        const dropdown = document.getElementById('categorylistVersions');
        dropdown.innerHTML = ''; // Clear existing options

        data.forEach(item => {
            const option = document.createElement('option');
            const icon = item.approved ? '✅' : '❌';
            option.value = item.version;
            option.textContent = `${item.version}`;
            dropdown.appendChild(option);
        });
        // Refresh Bootstrap selectpicker UI
        $('.selectpicker').selectpicker('refresh');
        $('.selectpicker').selectpicker('refresh');

        dropdown.addEventListener('change', async (event) => {
            versionId = event.target.value;  // single value
            var loadingSpinnerContainer = document.getElementById('loadingSpinnerContainer');
            loadingSpinnerContainer.style.display = 'block';
            await getCategorylistIdcol();
            await fillCountries();
            await getCategorylistDetails(versionId);
        });
        versionId = data[0].version;
        // example of next version id

        await getCategorylistIdcol();
        await fillCountries();
        await getCategorylistDetails(versionId);
        document.getElementById('activateEditMode').disabled = false;
        document.getElementById('activateEditMode').style.backgroundColor = '#fafafa';
        document.getElementById('activateEditMode').style.cursor = 'pointer';
        document.getElementById('activateEditMode').onclick = function() {
            activateEditMode();
        };
    } catch (error) {
        console.error(error.message);
        showMessage(error.message, false);
    }
}

var categorylistLabels = {};
async function getCategorylistLabelOptions() {
    try {   
        var catlabels = await unifiedSendRequest(GETCATEGORYLISTLABELSV2DETAILS + `?version=${versionId}`, {method: 'GET'});
        col_order = catlabels['col_order'];
        categorylistLabels = catlabels['output_dict'];
    } catch (error) {
        console.error(error.message);
        showMessage('Failed to get categorylist labels', false);
    }
}

var idcol = null;
async function getCategorylistIdcol() {
    idcol = await unifiedSendRequest(GETCATEGORYLISTIDCOL, {method: 'GET'});
    return idcol;
}

async function fillCountries() {
    const tabsContainer = document.getElementById('tabs-container');
    tabsContainer.innerHTML = '';
    try {
        var countryOptions = await unifiedSendRequest(GETCATEGORYLISTCOUNTRIES + `?version=${versionId}`, {method: 'GET'});
        const sortedCountryOptions = countryOptions.sort((a, b) => {
            if (a === 'BE') return 1;    // BE goes after everything else
            if (b === 'BE') return -1;
            return a.localeCompare(b);  // default alphabetical
          });
        sortedCountryOptions.forEach(countryName => {
            // TODO should I check if there are more than 10 countries?
            const tabButton = document.createElement('button');
            tabButton.textContent = countryName;
            tabButton.className = 'tab-button';
            tabButton.dataset.country = countryName;
            tabButton.addEventListener('click', async () => {
                if (countryName === country) {
                    country = null;
                    countryName = null;
                } else {
                    country = countryName;
                }
                highlightActiveTab(countryName);
                await getCategorylistDetails();
            });
            tabsContainer.appendChild(tabButton);
        });
        country = sortedCountryOptions[0];
        highlightActiveTab(country);
    } catch (error) {
        console.error(error.message);
        showMessage('Failed to fill countries', false);
    }
}

function highlightActiveTab(activeCountry) {
    const buttons = document.querySelectorAll('.tab-button');
    buttons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.country === activeCountry);
    });
}

var limit = 10;
var offset = 0;
var total = 0;
var next_offset = null;
var prev_offset = null;
var pages = 1;
var order_by = null; // e.g. "column asc" or "column desc" or null
var country = null;
async function getCategorylistItems() {
    params = {
        version: versionId,
        limit: limit,
        offset: offset,
    };
    if (country) {
        params.country = country;
    }
    if (order_by) {
        params.order_by = order_by;
    }
    const search = document.getElementById('search').value;
    if (search) {
        params.search = search;
    }
    try {
        let data = await unifiedSendRequest(CATEGORYLIST + '?' + new URLSearchParams(params).toString(), {method: 'GET'});
        pages = data.pages;
        total = data.total;
        next_offset = data.next_offset;
        prev_offset = data.prev_offset;
        current_page = offset / limit + 1;
        document.getElementById('offset').innerHTML = offset + 1;
        document.getElementById('offsetEnd').innerHTML = Math.min(offset + limit, total);
        document.getElementById('total').innerHTML = total;
        renderPagination(current_page, pages, limit);
        document.getElementById('tableFooter').style.display = 'flex';
        return data;
    } catch (error) {
        console.error(error.message);
        showMessage('Failed to get catalog items', false);
        return [];
    }
}


function renderPagination(current_page, total_pages, limit) {
    const container = document.getElementById('pagination');
    container.innerHTML = '';

    const buttons = ['<<', '<', current_page - 1, current_page, current_page + 1, '>', '>>'];

    buttons.forEach(label => {
        // Skip invalid page numbers
        if (typeof label === 'number' && (label < 1 || label > total_pages)) return;

        const btn = document.createElement('div');
        btn.textContent = label;
        btn.disabled = label === current_page; // disable current page
        btn.className = label === current_page ? 'active' : '';
        btn.classList.add('pagination-item');

        btn.addEventListener('click', async () => {
            let targetPage = current_page;

            if (label === '<<') targetPage = 1;
            else if (label === '<') targetPage = Math.max(1, current_page - 1);
            else if (label === '>') targetPage = Math.min(total_pages, current_page + 1);
            else if (label === '>>') targetPage = total_pages;
            else if (typeof label === 'number') targetPage = label;

            offset = (targetPage - 1) * limit;
            await getCategorylistDetails();
        });

        container.appendChild(btn);
    });
}

var columnMapping = {};
let draggedElement = null;

function handleDragStart(e) {
    draggedElement = this;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    
    // Remove drag-over class from all th elements
    document.querySelectorAll('#editableTable thead th').forEach(th => {
        th.classList.remove('drag-over');
    });
    
    // Add drag-over class to current target
    if (this !== draggedElement) {
        this.classList.add('drag-over');
    }
    return false;
}

function handleDragEnd(e) {
    this.classList.remove('dragging');
    document.querySelectorAll('#editableTable thead th').forEach(th => {
        th.classList.remove('drag-over');
    });
    draggedElement = null;
}

async function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    
    if (draggedElement !== this) {
        const thead = document.querySelector('#editableTable thead tr');
        const tbody = document.querySelector('#editableTableBody tbody');
        
        // Get all header cells with current order
        const allHeaders = Array.from(thead.querySelectorAll('th'));
        const draggedIndex = allHeaders.indexOf(draggedElement);
        const targetIndex = allHeaders.indexOf(this);
        
        if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) {
            return false;
        }
        
        // Store references before DOM manipulation
        const draggedHeader = draggedElement;
        const targetHeader = this;
        
        // Reorder headers: remove dragged element and insert at target position
        draggedHeader.remove();
        
        if (draggedIndex < targetIndex) {
            // Moving right: insert after target
            targetHeader.after(draggedHeader);
        } else {
            // Moving left: insert before target
            targetHeader.before(draggedHeader);
        }
        
        // Reorder body cells for each row
        const rows = Array.from(tbody.querySelectorAll('tr'));
        rows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td'));
            if (cells.length > Math.max(draggedIndex, targetIndex)) {
                // Store references before any DOM manipulation
                const draggedCell = cells[draggedIndex];
                const targetCell = cells[targetIndex];
                
                // Remove dragged cell from DOM
                draggedCell.remove();
                
                // Insert at new position
                if (draggedIndex < targetIndex) {
                    // Moving right: insert after target
                    targetCell.after(draggedCell);
                } else {
                    // Moving left: insert before target
                    targetCell.before(draggedCell);
                }
            }
        });
        
        // Update column order and call updateOrder
        await updateOrder();
    }
    
    this.classList.remove('drag-over');
    return false;
}

async function updateOrder() {
    const thead = document.querySelector('#editableTable thead tr');
    const headers = Array.from(thead.querySelectorAll('th'));
    const newOrder = headers.map(th => th.dataset.name);
    
    // You can add your API call here to persist the column order
    // For example:
    // const formData = new FormData();
    // formData.append('version_id', versionId);
    // formData.append('col_order', JSON.stringify(newOrder));
    // await unifiedSendRequest(UPDATE_COLUMN_ORDER_ENDPOINT, {formData: formData});
    
    try {
        var formData = new FormData();
        formData.append('new_order', JSON.stringify(newOrder));
        var data = await unifiedSendRequest(UPDATECATEGORYLISTORDER, {formData: formData});
        if (data.success) {
            showMessage(data.message, true);
        } else {
            showMessage(data.message, false);
        }
    } catch (error) {
        console.error(error.message);
        showMessage('Failed to update order', false);
    }
}

async function getCategorylistDetails() {
    var loadingSpinnerContainer = document.getElementById('loadingSpinnerContainer');
    loadingSpinnerContainer.style.display = 'block';
    let data = await getCategorylistItems();
    if (data.data.length === 0) {
        loadingSpinnerContainer.style.display = 'none';
        return;
    }
    let headers = Object.keys(data.data[0]);
    let thead = document.querySelector('#editableTable thead');
    thead.innerHTML = '';
    let tr = document.createElement('tr');
    columnMapping = data.column_mapping;
    headers.forEach(header => {
        let th = document.createElement('th');
        let div = document.createElement('div');
        div.className = 'flex-header';
        let [out, maxChars] = splitHeaderInTwo(header);
        var displayHeader = document.createElement('span');
        displayHeader.className = 'col-name';
        displayHeader.innerHTML = out;
        displayHeader.dataset.name = header;
        displayHeader.style.cursor = 'pointer';
        div.appendChild(displayHeader);
        const sortIcon = document.createElement('span');
        sortIcon.className = 'sort-icon';
        sortIcon.innerHTML = order_by && order_by.startsWith(header) ? (order_by.endsWith('asc') ? '▲' : '▼') : '⇅';
        sortIcon.style.marginLeft = '5px';
        sortIcon.style.color = order_by && order_by.startsWith(header) ? '#2255ff' : '#ccc';
        sortIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSort(header, th);
        });
        div.appendChild(sortIcon);
        th.appendChild(div);
        th.dataset.maxChars = maxChars;
        th.dataset.name = header;
        th.title = columnMapping[header].description;
        th.dataset.unit = columnMapping[header].unit;
        th.addEventListener('mouseenter', function() {
            currentTh = th;
            clearTimeout(deleteColButtonTimer);
            deleteColumnButton();
        });
        th.addEventListener('mouseleave', function() {
            deleteColButtonTimer = setTimeout(function() {
                $('#deleteButton').hide();
            }, 1000);
        });
        th.querySelector('.col-name').addEventListener('click', (e) => {
            if (!editMode) {
                return;
            }
            e.stopPropagation();
            renameColumn(displayHeader);
        });
        // Add drag and drop functionality
        th.draggable = true;
        th.addEventListener('dragstart', handleDragStart);
        th.addEventListener('dragover', handleDragOver);
        th.addEventListener('drop', handleDrop);
        th.addEventListener('dragend', handleDragEnd);
        tr.appendChild(th);
    });
    thead.appendChild(tr);
    let tbody = document.querySelector('#editableTableBody tbody');
    tbody.innerHTML = '';
    data.data.forEach(item => {
        let tr = document.createElement('tr');
        tr.dataset.id = item[idcol];
        tr.id = item[idcol];
        first = true;
        headers.forEach(key => {
            const td = document.createElement('td');
            td.textContent = item[key];
            td.title = key;
            if (columnMapping[key].unit) {
                td.title += ` in ${columnMapping[key].unit}`;
            }
            td.dataset.id = item[idcol];
            td.dataset.unit = columnMapping[key].unit;
            td.dataset.name = key;
            if (first) {
                td.addEventListener('mouseenter', function() {
                    currentRow = td;
                    clearTimeout(deleteRowButtonTimer);
                    deleteRowButton();
                });
                td.addEventListener('mouseleave', function() {
                  deleteRowButtonTimer = setTimeout(function() {
                      $('#deleteButtonRow').hide();
                  }, 1000);
                });
                first = false;
            }
            else {
                td.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editCell(td, false, td.querySelector('.feature-title-text'));
                    return;
                });
            }
            tr.appendChild(td);
          });
        tbody.appendChild(tr);
    });
    alignWidth(thead, tbody);
    loadingSpinnerContainer.style.display = 'none';
    checkForErrors();
    if (window.userPermissions['subsku']) {
        tbody.querySelectorAll('tr').forEach(tr => {
            addFeature(tr, tr.dataset.id);
        });
    }
}
let deleteRowButtonTimer;
let deleteColButtonTimer;
function deleteColumnButton() {
    if (!editMode) {
      return;
     }
      // Your code for the mouseenter event
      clearTimeout(deleteColButtonTimer); // Clear existing timer
      const btn = document.getElementById('deleteButton');
      const thRect = currentTh.getBoundingClientRect();
      btn.style.top = `${thRect.top + window.scrollY - 20}px`; // Adjust as needed
      btn.style.left = `${thRect.left + (thRect.width / 2) - 10}px`; // Adjust as needed
      btn.style.display = 'block';
  }

  function deleteRowButton() {
     if (!editMode) {
        return;
      }
      clearTimeout(deleteRowButtonTimer); // Clear existing timer
      const btn = document.getElementById('deleteButtonRow');
      const thRect = currentRow.getBoundingClientRect();
      btn.style.top = `${thRect.top + window.scrollY + 5}px`; // Adjust as needed
      btn.style.left = `${thRect.left - 20}px`; // Adjust as needed
      btn.style.display = 'block';
  }

  let currentTh = null;
  async function deleteColumn() {
    // Delete the column
    // closePopup();
    const columnName = currentTh.dataset.name;
    if(confirm(`Are you sure you want to delete ${columnName}?`)){
        var oldMapping = categorylistLabels[columnName];
        if (oldMapping) {
            oldMapping = oldMapping.key;
        } else {
            oldMapping = '';
        }
        var formData = new FormData();
        formData.append('oldColumnName', columnName);
        formData.append('oldMapping', oldMapping);
        formData.append('version_id', versionId);
        var data = await unifiedSendRequest(CATEGORYLISTDELETECOLUMN, {formData: formData});
        if (data.success) {
            showMessage(data.message, true);
            await getCategorylistDetails();
        } else {
            showMessage(data.message, false);
        }
    }
}
let currentRow = null;
async function deleteRow() {
    const columnName = currentRow.dataset.id;
    clearTimeout(deleteRowButtonTimer);
    if(confirm(`Are you sure you want to delete ${columnName}?`)) {
        const rowId = currentRow.dataset.id;
        const formData = new FormData();
        formData.append('sku', rowId);
        formData.append('version', versionId);
        var data = await unifiedSendRequest(CATEGORYLISTDELETEROW, {formData: formData});
        showMessage('Row deleted', true);
            await getCategorylistDetails();
    }
}

async function openAddRowModal() {
    document.getElementById('addRowModal').style.display = 'block';
    document.getElementById('addRowInput').value = '';
}

async function closeAddRowModal() {
    document.getElementById('addRowModal').style.display = 'none';
}

async function saveAddRow() {
    var sku = document.getElementById('addRowInput').value;
    const formData = new FormData();
    formData.append('sku', sku);
    formData.append('version', versionId);
    try {
        var data = await unifiedSendRequest(CATEGORYLISTADDROW, {formData: formData});
        if (data.success) {
            showMessage(data.message, true);
            await getCategorylistDetails();
            closeAddRowModal();
        } else {
            showMessage(data.message, false);
        }
    } catch (error) {
        console.error(error.message);
        showMessage(error.message, false);
        closeAddRowModal();
    }
}

async function getCategorylistLabelsV2Options() {
    try {
      const data = await unifiedSendRequest(GETCATEGORYLISTLABELSV2OPTIONS, {method: 'GET'});
      return data;
    } catch (error) {
      console.error(error.message);
      showMessage('Failed to get categorylist label options ' + error.message, false);
      return [];
    }
}
  
var labelsV2Options = null;

async function renameColumn(displayHeader) {
    document.body.style.cursor = 'wait';
    var currentText = displayHeader.dataset.name;
    console.log(currentText);
    if (Object.keys(categorylistLabels).length === 0) {
        await getCategorylistLabelOptions();
    }
    var currentLabel = categorylistLabels[currentText];
    console.log(currentLabel);
    if (currentLabel) {
      currentLabel = currentLabel.key;
    } else {
      currentLabel = '';
    }
    document.getElementById('currentColumnName').textContent = currentText;
    document.getElementById('renameColumnInput').value = currentText;
    document.getElementById('renameColumnMapping').innerHTML = '';
    var unmappedOption = document.createElement('option');
    unmappedOption.value = '';
    unmappedOption.textContent = 'Unmapped';
    document.getElementById('renameColumnMapping').appendChild(unmappedOption);
    
    if (!labelsV2Options) {
      labelsV2Options = await getCategorylistLabelsV2Options();
    }
    Object.keys(labelsV2Options).forEach(groupKey => {
      var optionGroup = document.createElement('optgroup');
      optionGroup.label = groupKey;
      optionGroup.setAttribute('data-name', groupKey);
      labelsV2Options[groupKey].forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option.key;
        optionElement.setAttribute('data-units', option.options);
        var star = '';
        if (option.required) {
          star = ' *';
        }
        if (option.key === currentLabel) {
          optionElement.selected = true;
        }
        optionElement.setAttribute('data-description', option.description);
        optionElement.title = option.description;
        optionElement.textContent = option.title + star;
        optionGroup.appendChild(optionElement);
      });
      document.getElementById('renameColumnMapping').appendChild(optionGroup);
    });
    document.getElementById('renameColumnModal').style.display = 'block';
    $('#deleteButtonRow').hide();
    $('#deleteButton').hide();
    document.body.style.cursor = 'default';
  }
  
async function saveRenameColumn() {
    var oldColumnName = document.getElementById('currentColumnName').textContent.trim();
    var newColumnName = document.getElementById('renameColumnInput').value.trim();
    var newMapping = document.getElementById('renameColumnMapping').value;
    var oldMapping = categorylistLabels[oldColumnName];
    if (oldMapping && oldMapping.key !== undefined) {
      oldMapping = oldMapping.key;
    } else {
      oldMapping = '';
    }
    var formData = new FormData();
    formData.append('oldColumnName', oldColumnName);
    formData.append('newColumnName', newColumnName);
    formData.append('newMapping', newMapping);
    formData.append('oldMapping', oldMapping);
    formData.append('version_id', versionId);
    try {
    var data = await unifiedSendRequest(CATEGORYLISTRENAMECOLUMN, {formData: formData});
      if (data.success) {
        closeRenameColumnModal();
        showMessage(data.message, true);
        await fillVersionDropdown();
        await getCategorylistLabelOptions();
      } else {
        showMessage(data.message, false);
      }
    } catch (error) {
      console.error(error.message);
      showMessage(error.message, false);
    }
}

function closeRenameColumnModal() {
    document.getElementById('renameColumnModal').style.display = 'none';
}

function closeAddColumnModal() {
    document.getElementById('addColumnModal').style.display = 'none';
}

async function openAddColumnModal() {
        document.body.style.cursor = 'wait';
        if (!labelsV2Options) {
          labelsV2Options = await getCategorylistLabelsV2Options();
        }
        document.getElementById('addColumnMapping').innerHTML = '';
        var unmappedOption = document.createElement('option');
        unmappedOption.value = '';
        unmappedOption.textContent = 'Unmapped';
        document.getElementById('addColumnMapping').appendChild(unmappedOption);
        Object.keys(labelsV2Options).forEach(groupKey => {
          var optionGroup = document.createElement('optgroup');
          optionGroup.label = groupKey;
          optionGroup.setAttribute('data-name', groupKey);
          labelsV2Options[groupKey].forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.key;
            optionElement.setAttribute('data-units', option.options);
            var star = '';
            if (option.required) {
              star = ' *';
            }
            optionElement.textContent = option.title + star;
            optionElement.setAttribute('data-description', option.description);
            optionElement.title = option.description;
            optionGroup.appendChild(optionElement);
          });
          document.getElementById('addColumnMapping').appendChild(optionGroup);
        });
        document.getElementById('addColumnModal').style.display = 'block';

        $('#deleteButtonRow').hide();
        $('#deleteButton').hide();
        document.body.style.cursor = 'default';
}

async function saveAddColumn() {
    var newColumnName = document.getElementById('addColumnInput').value.trim();
    var newMapping = document.getElementById('addColumnMapping').value;
    var formData = new FormData();
    formData.append('newColumnName', newColumnName);
    formData.append('newMapping', newMapping);
    formData.append('version_id', versionId);
    var data = await unifiedSendRequest(CATEGORYLISTADDCOLUMN, {formData: formData});
    if (data.success) {
      closeAddColumnModal();
      showMessage(data.message, true);
      await fillVersionDropdown();
      await getCategorylistLabelOptions();
    } else {
      showMessage(data.message, false);
    }
}

async function checkForErrors() {
    if (Object.keys(categorylistLabels).length === 0) {
        await getCategorylistLabelOptions();
    }
    let tbody = document.querySelector('#editableTableBody tbody');
    tbody.querySelectorAll('tr').forEach(tr => {
        tr.querySelectorAll('td').forEach(td => {
            checkForErrorsInCell(td);
        });
    });
}

function checkForErrorsInCell(td) {
    if (td.dataset.name in categorylistLabels) {
        subentries = categorylistLabels[td.dataset.name].subentries;
        if (subentries.length > 0) {
            let foundEntry = false;
            subentries.forEach(subentry => {
                if (String(td.textContent) === String(subentry.key)) {
                    td.title = subentry.title;
                    foundEntry = true;
                }
            });
            if (!foundEntry && td.textContent !== '') {
                td.title = 'Invalid entry found';
                td.classList.add('invalid-entry');
            } else {
                td.classList.remove('invalid-entry');
            }
        }
    }
}

var currentEditor = null;
var currentDropdown = null;
async function editCell(td, features = false, featureTitleContainer = null) {
    if (!editMode) return;
    console.log('editCell', td, features, featureTitleContainer);
    // Skip if already editing
    if (td.querySelector('input')) return;
    closeCurrentEditor();
    if (featureTitleContainer) {
        originalContent = featureTitleContainer.textContent;
    } else {
        originalContent = td.textContent;
    }
    const subentries = categorylistLabels[td.dataset.name]?.subentries || [];
    if (subentries.length > 0) {
        const input = $('<input>', {
            type: 'text',
            class: 'inline-editor',
            value: originalContent,
            autocomplete: 'off',
            css: { width: '100%', position: 'relative' }
          });
        const dropdown = $('<div>', { class: 'suggestion-box', 
            css: { position: 'absolute',
              top: 60,
              left: 0,
              background: '#fff', 
              border: '1px solid #ccc', 
              zIndex: 9999, 
              width: td.offsetWidth + 40,
              maxHeight: '150px', 
              overflowY: 'auto' } });
        subentries.forEach(subentry => {
            const option = $('<div>', {
                text: subentry.key,
                class: 'dropdown-option',
                title: subentry.title || '',
                css: { padding: '4px 8px', cursor: 'pointer' }
            });
            option.on('click', async () => {
                input.val(subentry.key);
                await saveValue(subentry.key, td, originalContent, features, featureTitleContainer);
                dropdown.hide();
            });
            dropdown.append(option);
        });
        // live filter
        input.on('input', () => {
            const q = input.val().toLowerCase();
            dropdown.children().each(function() {
                const txt = $(this).text().toLowerCase();
                const title = ($(this).attr('title') || '').toLowerCase();
                $(this).toggle(txt.includes(q) || title.includes(q));
            });
        });
        input.on('input', () => {
            if (subentries.length > 0) dropdown.show();
        });
        let keepDropdownOpen = false;
        dropdown.on('mousedown', () => { keepDropdownOpen = true; });
        input.on('blur', async () => {
            if (!keepDropdownOpen) await saveValue(input.val(), td, originalContent, features, featureTitleContainer);
            setTimeout(() => { keepDropdownOpen = false; }, 200);
        });
        input.on('keydown', async (e) => {
            if (e.key === 'Enter') await saveValue(input.val(), td, originalContent, features, featureTitleContainer);
            if (e.key === 'Escape') {
                dropdown.hide();
                td.textContent = originalContent;
            }
        });
        if (featureTitleContainer) {
            featureTitleContainer.innerHTML = '';
            featureTitleContainer.appendChild(input[0]);
            featureTitleContainer.appendChild(dropdown[0]);
        } else {
            td.innerHTML = '';
            td.appendChild(input[0]);
            td.appendChild(dropdown[0]);
        }
        input.focus();
        currentEditor = input[0];
        currentDropdown = dropdown[0];
    } else {
        const input = document.createElement('input');
        input.value = originalContent;
        input.style.width = '100%';
        input.style.position = 'relative';
        input.addEventListener('blur', async () => {
            await saveValue(input.value, td, originalContent, features, featureTitleContainer);
        });
        input.addEventListener('keyup', async (e) => {
            if (e.key === 'Enter') input.blur();
            if (e.key === 'Escape') {
                input.value = originalContent;
                await saveValue(originalContent, td, originalContent, features, featureTitleContainer);
            }
        });
        if (featureTitleContainer) {
            featureTitleContainer.innerHTML = '';
            featureTitleContainer.appendChild(input);
        } else {
            td.innerHTML = '';
            td.appendChild(input);
        }
        input.focus();
        currentEditor = input;
        currentDropdown = null;
    }
}

async function saveValue(value, td, originalContent, features = false, featureTitleContainer = null) {
    if (value !== originalContent) {
        const formData = new FormData();
        formData.append('column', td.dataset.name);
        if (value) {
            formData.append('value', value);
        }
        if(originalContent) {
            formData.append('old_value', originalContent);
        }
        formData.append('version', versionId);
        try {
            if (!features) {
                const res = await unifiedSendRequest(`${CATEGORYLIST}/${td.dataset.id}`, {
                    method: 'PUT',
                    formData: formData
                });
                if (res.reload) {
                    await getCategorylistDetails();
                }
            } else {
                formData.append('feature_id', td.dataset.id);
                const res = await unifiedSendRequest(`${CATEGORYLISTFEATURES}/${td.dataset.id}`, {
                    method: 'PUT',
                    formData: formData
                });
                refreshFeatures();
            }
        } catch (error) {
            console.error(error.message);
            showMessage('Failed to save value', false);
        }
    }
    closeCurrentEditor();
    if (featureTitleContainer) {
        featureTitleContainer.innerHTML = '';
        featureTitleContainer.textContent = value;
    } else {
        td.innerHTML = '';
        td.textContent = value;
    }
    checkForErrorsInCell(td);
}

function closeCurrentEditor() {
    if (currentEditor) {
        currentEditor.remove();
        currentEditor = null;

    }
    if (currentDropdown) {
        currentDropdown.remove();
        currentDropdown = null;
    }
}

async function saveData() {
    const formData = new FormData();
    formData.append('version', versionId);
    try {
        const res = await unifiedSendRequest(`${CATEGORYLIST}/save`, {
            method: 'POST',
            formData: formData
        });
        showMessage('Data saved', true);
        await fillVersionDropdown();
        deactivateEditMode();
    } catch (error) {
        console.error(error.message);
        showMessage('Failed to save data', false);
    }
}

async function toggleSort(column, th) {
    const icon = th.querySelector('.sort-icon');
    const current =
      order_by && order_by.startsWith(column)
        ? order_by.endsWith('asc')
          ? 'asc'
          : 'desc'
        : null;
  
    let next;
    if (current === null) next = 'asc';
    else if (current === 'asc') next = 'desc';
    else next = null;
  
    // update variable
    order_by = next ? `${column} ${next}` : null;
  
    // reset all icons
    document.querySelectorAll('.sort-icon').forEach(i => {
      i.style.color = '#ccc';
      i.textContent = '⇅';
    });
  
    // update current icon
    icon.style.color = next ? '#2255ff' : '#ccc';
    icon.textContent = next === 'asc' ? '▲' : next === 'desc' ? '▼' : '⇅';
  
    await getCategorylistDetails();
}

async function changeRowsPerPage() {
    limit = document.getElementById('rowsPerPage').value;
    offset = 0;
    await getCategorylistDetails();
}

document.getElementById('rowsPerPage').addEventListener('change', changeRowsPerPage);
let searchTimeout;
document.getElementById('search').addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(async () => {
      await getCategorylistDetails();
    }, 500); // wait 500 ms after last keystroke
  });

function alignWidth(thead, tbody) {
    // compute max width for each column
    const ths = thead.querySelectorAll('th');
    const rows = tbody.querySelectorAll('tr');
    var first = true;
    ths.forEach((th, i) => {
    // start with header width
    let maxWidth = th.offsetWidth;
    if (first) {
        maxWidth = 400;   // minimum width for first column
        first = false;
    }
    estimatedWidth = estimateWidth(th.dataset.maxChars);
    // apply the final width to both header and body cells
    maxWidth = Math.max(maxWidth, estimatedWidth);
    th.style.width = maxWidth + 'px';
    rows.forEach(row => {
        const td = row.children[i];
        if (td) td.style.width = maxWidth + 'px';
    });
    });
}

function estimateWidth(chars, fontSize = 14, padding = 20) {
    const avgCharWidth = fontSize * 0.6;      // ~0.6 em per char for sans-serif
    return chars * avgCharWidth + padding;
}

    /**
  * returns an HTML **string** where…
  *   • the header is split in TWO halves (closest possible to 50 / 50)
  *     **only** at " ", "/", "-", "_"                                  *
  *   • every other occurrence of those characters becomes unbreakable  *
  */
function splitHeaderInTwo(header) {
// characters at which we may split
const BREAK_CHARS = [' ', '/', '-', '_'];

/* 1️⃣  collect the positions of every break-character */
const breakPoints = [...header]
    .map((ch, idx) => BREAK_CHARS.includes(ch) ? idx : -1)
    .filter(idx => idx !== -1);

// nothing to split on → return as-is
if (breakPoints.length === 0) return [header, header.length];

/* 2️⃣  choose the position closest to the middle */
const mid      = header.length / 2;
const splitIdx = breakPoints.reduce(
    (best, cur) => Math.abs(cur - mid) < Math.abs(best - mid) ? cur : best,
    breakPoints[0]
);

/* 3️⃣  rebuild the string with exactly one <wbr>
        and NB-spaces / NB-hyphens everywhere else          */
let out = '';
firstHalfLength = splitIdx;
secondHalfLength = header.length - firstHalfLength;
var maxChars = Math.max(firstHalfLength, secondHalfLength);
for (let i = 0; i < header.length; i++) {
    const ch = header[i];

    if (i === splitIdx) {               // ← chosen break-point
    out += ch;
    if (ch === '/') {
      out += ' ';
    }
    continue;
    }

    switch (ch) {                       // make all other breaks non-breaking
    case ' ' : out += '&nbsp;';   break;   // non-breaking space
    case '-' : out += '&#8209;';   break;  // non-breaking hyphen
    default  : out += ch;                  // '//' and '_' never break anyway
    }
}
return [out, maxChars];
}

</script>